<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>ä½ çŒœçŒœ - ç•«å¸ƒ + èŠå¤©</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <div class="app-layout">
    <aside class="sidebar">
      <header class="sidebar-header">
        <div class="logo">ä½ çŒœçŒœ</div>
        <div class="me-info">
          <span class="me-name" id="meNameDisplay">å°šæœªåŠ å…¥</span>
        </div>
      </header>

      <section class="card small-card">
        <div class="round-row">
          <span class="round-label">ç•«å®¶ï¼š</span>
          <span id="drawerName">å°šæœªé–‹å§‹</span>
        </div>
        <div class="round-row">
          <span class="round-label">é¡Œç›®ï¼š</span>
          <span id="wordHint">å°šæœªå‡ºé¡Œ</span>
        </div>
        <p id="roundInfo" class="round-info-text">è«‹ç­‰å¾…éŠæˆ²é–‹å§‹...</p>
      </section>

      <section class="card" id="drawerSection" style="display:none;">
        <h2 class="card-title">è¼ªåˆ°ä½ å‡ºé¡Œ ğŸ¨</h2>
        <label class="field-label">
          è¼¸å…¥é¡Œç›®
          <input id="wordInput" class="text-input" placeholder="ä¾‹å¦‚ï¼šè²“å’ªã€è˜‹æœã€é›»è…¦...">
        </label>
        <button id="startBtn" class="primary-btn">é–‹å§‹é€™ä¸€å›åˆ</button>
      </section>

      <section class="card chat-card">
        <h2 class="card-title">èŠå¤©å®¤ / çŒœé¡Œå€</h2>
        <div id="chatLog" class="chat-log"></div>
        <div class="chat-input-row">
          <input id="chatInput" class="text-input" placeholder="è¼¸å…¥è¨Šæ¯ï¼ˆä¹Ÿæœƒç•¶ä½œçŒœé¡Œï¼‰ï¼ŒæŒ‰ Enter é€å‡º">
          <button id="chatSendBtn" class="secondary-btn">é€å‡º</button>
        </div>
      </section>

      <section class="card score-card">
        <h2 class="card-title">åˆ†æ•¸æ’è¡Œæ¦œ</h2>
        <pre id="scoreBoard" class="score-text">å°šæœªæœ‰åˆ†æ•¸</pre>
      </section>
    </aside>

    <main class="canvas-main">
      <header class="canvas-header">
        <div>æˆ¿é–“ç•«å¸ƒï¼ˆå…¨å“¡å…±ç”¨ï¼‰</div>
      </header>

      <div class="canvas-wrapper">
        <canvas id="myCanvas" width="800" height="500"></canvas>

        <div class="toolbar">
          <div class="tools-left">
            <button class="tool-btn active" data-tool="pen">âœï¸</button>
            <button class="tool-btn" data-tool="fill">ğŸª£</button>
            <button class="tool-btn" data-tool="eraser">ğŸ§¼</button>
            <button class="tool-btn btn-clear" id="clearBtn">ğŸ—‘ï¸</button>
          </div>

          <input type="range" class="size-slider" id="sizePicker" min="2" max="40" value="5">

          <div class="colors" id="colorPalette"></div>
        </div>
      </div>
    </main>
  </div>

  <script src="/socket.io/socket.io.js"></script>

  <script>
    // ============================================================
    // 1. Socket.ioï¼šæˆ¿é–“ / å‡ºé¡Œ / çŒœé¡Œ / èŠå¤©
    // ============================================================
    const socket = io();
    
    function getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        return {
            username: params.get('username'),
            roomId: params.get('roomId')
        };
    }

    const meNameDisplay = document.getElementById('meNameDisplay');
    const drawerNameSpan = document.getElementById('drawerName');
    const wordHintSpan Â  = document.getElementById('wordHint');
    const roundInfo Â  Â  Â = document.getElementById('roundInfo');

    const drawerSection Â = document.getElementById('drawerSection');
    const wordInput Â  Â  Â = document.getElementById('wordInput');
    const startBtn Â  Â  Â  = document.getElementById('startBtn');

    const chatLog Â  Â  = document.getElementById('chatLog');
    const chatInput Â  = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');

    const scoreBoard Â = document.getElementById('scoreBoard');

    const state = {
        roomId: null,
        userId: null, 
        nickname: null,
    };
    
    // ç­‰å¾… socket é€£ç·šå»ºç«‹å¾Œï¼Œå°‡ socket.id è³¦äºˆçµ¦ state.userId
    socket.on('connect', () => {
        state.userId = socket.id;
        autoJoinRoom(); // é€£ç·šæˆåŠŸå¾Œï¼Œç«‹å³å˜—è©¦è‡ªå‹•åŠ å…¥æˆ¿é–“
    });

    function appendChatLine(text, type = 'normal') {
      const div = document.createElement('div');
      div.classList.add('chat-line');
      if (type === 'system') div.classList.add('chat-line-system');
      if (type === 'me') div.classList.add('chat-line-me');
      div.textContent = text;
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function renderScores(scores) {
      if (!scores || Object.keys(scores).length === 0) {
        scoreBoard.textContent = 'å°šæœªæœ‰åˆ†æ•¸';
        return;
      }
      let lines = [];
      // é€™è£¡å‡è¨­ scores éµå€¼å°ç‚º { userId: score }
      for (const [userId, score] of Object.entries(scores)) {
        // ç‚ºäº†åœ¨æ²’æœ‰æš±ç¨±çš„æƒ…æ³ä¸‹å€åˆ†ç”¨æˆ¶ï¼Œæˆ‘å€‘åªé¡¯ç¤ºéƒ¨åˆ† ID
        let displayId = (userId === state.userId) ? state.nickname : `ID=${userId.substring(0, 5)}...`;
        lines.push(`${displayId}ï¼š${score} åˆ†`); 
      }
      scoreBoard.textContent = lines.join('\n');
    }

    // ğŸ¯ è‡ªå‹•åŠ å…¥æˆ¿é–“é‚è¼¯
    function autoJoinRoom() {
        if (!state.userId) return; 
        
        const { username, roomId } = getUrlParams();
        
        if (!roomId || !username) {
            alert('éŒ¯èª¤ï¼šç¼ºå°‘æˆ¿é–“ ID æˆ–ç”¨æˆ¶åï¼å°‡å°å›ç™»å…¥é é¢ã€‚');
            window.location.href = 'login.html'; // å°å›ç™»å…¥é é¢
            return;
        }

        state.roomId = roomId;
        state.nickname = username;
        
        const nickname = username;
        const userId = state.userId;

        // ç™¼é€ joinRoom äº‹ä»¶
        socket.emit('joinRoom', { roomId, userId, nickname });

        meNameDisplay.textContent = nickname;
        appendChatLine(`ä½ å·²è‡ªå‹•åŠ å…¥æˆ¿é–“ ${roomId}`, 'system');
        roundInfo.textContent = 'æˆ¿é–“åˆå§‹åŒ–å®Œæˆï¼Œç­‰å¾…éŠæˆ²é–‹å§‹...';
    }


    // å‡ºé¡Œï¼ˆé–‹å§‹å›åˆï¼‰
    startBtn.addEventListener('click', () => {
      const word = wordInput.value.trim();
      if (!word) {
        alert('è«‹è¼¸å…¥é¡Œç›®ï½');
        return;
      }
      if (!state.roomId) {
        alert('è«‹å…ˆåŠ å…¥æˆ¿é–“ï¼');
        return;
      }

      socket.emit('startRound', {
        roomId: state.roomId,
        word,
      });

      appendChatLine(`ä½ å‡ºé¡Œï¼šã€Œ${word}ã€`, 'system');
      wordInput.value = '';
    });

    // èŠå¤© / çŒœé¡Œé€å‡º
    function sendChatAndGuess() {
      const text = chatInput.value.trim();
      if (!text) return;
      if (!state.roomId) {
        alert('è«‹å…ˆåŠ å…¥æˆ¿é–“ï¼');
        return;
      }

      // 1. å»£æ’­èŠå¤©å®¤è¨Šæ¯
      socket.emit('chatMessage', {
        roomId: state.roomId,
        text,
      });

      // 2. åŒæ™‚ç•¶ä½œçŒœé¡Œ
      socket.emit('guess', {
        roomId: state.roomId,
        text,
      });

      appendChatLine(`ä½ ï¼š${text}`, 'me');
      chatInput.value = '';
    }

    chatSendBtn.addEventListener('click', sendChatAndGuess);
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendChatAndGuess();
      }
    });

    // ===== å¾Œç«¯äº‹ä»¶ (ä¿æŒä¸è®Š) =====
    socket.on('roundStartedForDrawer', ({ word }) => {
      drawerNameSpan.textContent = state.nickname || '(ä½ )';
      wordHintSpan.textContent = `${word}ï¼ˆä½ è‡ªå·±çŸ¥é“ç­”æ¡ˆ ğŸ˜†ï¼‰`;
      roundInfo.textContent = `æœ¬å›åˆé¡Œç›®å·²è¨­å®šï¼Œå­—æ•¸ï¼š${word.length}`;
      appendChatLine(`ã€ç³»çµ±ã€‘ä½ æœ¬å›åˆçš„é¡Œç›®æ˜¯ï¼šã€Œ${word}ã€`, 'system');
    });

    socket.on('roundStarted', ({ drawerNickname, wordLength }) => {
      drawerNameSpan.textContent = drawerNickname;
      wordHintSpan.textContent = `${wordLength} å€‹å­—`;
      roundInfo.textContent = `è¼ªåˆ° ${drawerNickname} ç•«åœ–ï¼Œé¡Œç›®æœ‰ ${wordLength} å€‹å­—ã€‚`;
      appendChatLine(`ã€ç³»çµ±ã€‘ç•«å®¶ï¼š${drawerNickname}ï¼Œé¡Œç›®æœ‰ ${wordLength} å€‹å­—ã€‚`, 'system');
    });

    socket.on('nextDrawer', ({ drawerSocketId, drawerNickname }) => {
      const isMeDrawer = (socket.id === drawerSocketId);
      drawerNameSpan.textContent = drawerNickname;

      if (isMeDrawer) {
        drawerSection.style.display = 'block';
        roundInfo.textContent = 'è¼ªåˆ°ä½ å‡ºé¡Œï¼Œè«‹è¼¸å…¥æ–°é¡Œç›®ï¼';
        appendChatLine('ã€ç³»çµ±ã€‘è¼ªåˆ°ä½ ç•¶ç•«å®¶äº†ï¼', 'system');
      } else {
        drawerSection.style.display = 'none';
        roundInfo.textContent = `ä¸‹ä¸€å›åˆè¼ªåˆ° ${drawerNickname} å‡ºé¡Œï¼Œè«‹ç­‰å¾…ä»–è¼¸å…¥é¡Œç›®ï½`;
        appendChatLine(`ã€ç³»çµ±ã€‘ä¸‹ä¸€å›åˆè¼ªåˆ° ${drawerNickname} å‡ºé¡Œã€‚`, 'system');
      }
    });

    socket.on('scoreUpdate', ({ scores }) => {
      renderScores(scores);
    });

    socket.on('roundEnded', ({ winnerUserId, drawerUserId, answer, scores }) => {
      renderScores(scores);
      wordHintSpan.textContent = `ç­”æ¡ˆï¼š${answer}`;
      roundInfo.textContent = `æœ¬å›åˆçµæŸï¼Œç­”æ¡ˆæ˜¯ã€Œ${answer}ã€ã€‚`;
      appendChatLine(`ğŸ‰ å›åˆçµæŸï¼ç­”æ¡ˆæ˜¯ã€Œ${answer}ã€ã€‚`, 'system');
    });

    socket.on('chatMessage', ({ nickname, userId, text }) => {
      appendChatLine(`${nickname}ï¼š${text}`);
    });

    // ============================================================
    // 2. ç•«å¸ƒåŒæ­¥ (ä¿æŒä¸è®Š)
    // ============================================================
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    // é€™è£¡ç¹¼çºŒä½¿ç”¨ä¸€å€‹ç¨ç«‹çš„ ID é€²è¡Œç•«å¸ƒåŒæ­¥ï¼Œèˆ‡éŠæˆ²é‚è¼¯çš„ state.userId åˆ†é–‹
    const userIdForCanvas = 'canvas_user_' + Math.random().toString(36).substr(2, 9); 

    let currentTool = 'pen';
    let currentColor = '#000000';
    let isDrawing = false;
    let lastX = 0, lastY = 0;
    let lastSyncedId = 0;
    let localVersion = -1; 

    // é¡è‰²é¸å–® (ä¿æŒä¸è®Š)
    const colors = [
      '#000000', '#555555', '#ffffff',
      '#ff0000', '#ff8800', '#ffff00',
      '#00ff00', '#00ffff', '#0000ff', '#800080'
    ];
    const paletteContainer = document.getElementById('colorPalette');

    colors.forEach((c, index) => {
      const div = document.createElement('div');
      div.className = 'color-swatch' + (index === 0 ? ' active' : '');
      div.style.backgroundColor = c;
      div.onclick = () => selectColor(c, div);
      paletteContainer.appendChild(div);
    });

    function selectColor(color, element) {
      currentColor = color;
      document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active'));
      element.classList.add('active');
    }

    // å·¥å…·æŒ‰éˆ• (ä¿æŒä¸è®Š)
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        const tool = btn.getAttribute('data-tool');
        currentTool = tool;
        document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // æ¸…ç©ºæŒ‰éˆ•
    document.getElementById('clearBtn').addEventListener('click', clearServerCanvas);

    // å–å¾—åº§æ¨™ (ä¿æŒä¸è®Š)
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    function startDraw(e) {
      e.preventDefault();
      const pos = getPos(e);

      if (currentTool === 'fill') {
        drawAndSend(pos.x, pos.y, pos.x, pos.y, 'fill');
      } else {
        isDrawing = true;
        [lastX, lastY] = [pos.x, pos.y];
        drawAndSend(pos.x, pos.y, pos.x, pos.y, currentTool);
      }
    }

    function moveDraw(e) {
      e.preventDefault();
      if (!isDrawing) return;
      const pos = getPos(e);
      drawAndSend(lastX, lastY, pos.x, pos.y, currentTool);
      [lastX, lastY] = [pos.x, pos.y];
    }

    function endDraw(e) {
      e.preventDefault();
      isDrawing = false;
    }

    // æ»‘é¼ /è§¸æ§äº‹ä»¶ (ä¿æŒä¸è®Š)
    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseout', endDraw);
    canvas.addEventListener('touchstart', startDraw, { passive: false });
    canvas.addEventListener('touchmove', Â moveDraw, Â { passive: false });
    canvas.addEventListener('touchend', Â  endDraw);

    function drawAndSend(x0, y0, x1, y1, type) {
      const size = document.getElementById('sizePicker').value;
      renderStroke(x0, y0, x1, y1, currentColor, size, type);

      fetch('/api/draw', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_id: userIdForCanvas,
          x0, y0, x1, y1, color: currentColor, size, type
        })
      }).catch(console.error);
    }

    function renderStroke(x0, y0, x1, y1, color, size, type) {
      if (type === 'fill') {
        floodFill(Math.floor(x0), Math.floor(y0), color);
        return;
      }
      ctx.beginPath();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = size;
      ctx.strokeStyle = (type === 'eraser') ? '#ffffff' : color;
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();
      ctx.closePath();
    }

    function floodFill(startX, startY, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const r = parseInt(fillColor.slice(1, 3), 16);
      const g = parseInt(fillColor.slice(3, 5), 16);
      const b = parseInt(fillColor.slice(5, 7), 16);

      const startPos = (startY * canvas.width + startX) * 4;
      const startR = data[startPos], startG = data[startPos+1], startB = data[startPos+2], startA = data[startPos+3];

      if (startR === r && startG === g && startB === b && startA === 255) return;

      const stack = [[startX, startY]];
      while (stack.length) {
        const [x, y] = stack.pop();
        if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
        const pos = (y * canvas.width + x) * 4;
        if (data[pos] !== startR || data[pos+1] !== startG || data[pos+2] !== startB || data[pos+3] !== startA) continue;

        data[pos] = r; data[pos+1] = g; data[pos+2] = b; data[pos+3] = 255;
        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // å®šæœŸåŒæ­¥å…¶ä»–äººçš„ç·šæ¢ (ä¿æŒä¸è®Š)
    setInterval(() => {
      fetch('/api/fetch_strokes?last_id=' + lastSyncedId)
        .then(res => res.json())
        .then(data => {
          if (localVersion === -1) {
            localVersion = data.version;
          } else if (data.version > localVersion) {
            // æœ‰äººæ¸…ç©ºäº†
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lastSyncedId = 0;
            localVersion = data.version;
            return;
          }

          if (data.strokes && data.strokes.length > 0) {
            data.strokes.forEach(s => {
              if (s.user_id !== userIdForCanvas) {
                renderStroke(s.x0, s.y0, s.x1, s.y1, s.color, s.size, s.type);
              }
              lastSyncedId = s.id;
            });
          }
        })
        .catch(console.error);
    }, 500);

    function clearServerCanvas() {
      fetch('/api/clear', { method: 'POST' })
        .then(res => res.json())
        .then(data => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          lastSyncedId = 0;
          localVersion = data.version;
        })
        .catch(console.error);
    }
  </script>
</body>
</html>